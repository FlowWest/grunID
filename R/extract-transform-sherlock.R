#' Process Sherlock Results
#' @description `process_sherlock()` extracts and transforms result data from the Synergy H1 reader
#' @param filepath Synergy H1 reader output excel file with corresponding plate run layout
#' in a sheet titled "plate_map"
#' @param sample_type either `mucus` or `fin_clip`
#' @param layout_type either `split_plate_early_late`, `split_plate_spring_winter`, `triplicate`,
#' `single_assay_ots28_early`, `single_assay_ots28_late`, `single_assay_ots16_spring`, or
#' `single_assay_ots16_winter`
#' @param plate_run_id plate run identifier generated by running `add_plate_run()`.
#' @param plate_size either 96 or 384
#' @details # Sample Details
#' The Synergy H1 result output from plate runs is organized using generic identifiers
#' that need to be mapped to the real sample identifiers in order to properly associate
#'  the results with the correct sample id in the database.The output file’s
#'  “Layout” section contains the well locations for samples encoded as non-unique generic
#'  sample ids (e.g., SPL1, BLK). The number of rows and columns in the Layout vary
#'  based on the plate size. A plate size 96 has rows A:H and columns 1:12 and
#'  a plate size 384 has rows A:P and columns 1:24. The results for each sample are
#'  found within columns that are the letter-number combination of the well location
#'  captured in the Layout section (e.g., if SPL1 is in row A and column 3,
#'  then the measurements at each time step are recorded in a column labeled A3).
#' To map the sample ids to the generic identifiers produced by the Synergy H1 software
#' (e.g., SPL1 and A3), the user must provide the true sample ids and other metadata
#' at each well location in the as a dataframe containing these columns:
#' * __location:__ _(character)_ letter-number combination based on Synergy H1 Layout grid (e.g., A3)
#' * __sample_id:__ _(character)_ unique ID of mucus swab or fin clip made up of site code, year,
#' sample event, sampling bin, and count within sampling bin (e.g., BTC22_3_A_1)
#' * __sample_type:__ _(numeric)_ provide 1 for mucus and 2 for fin clip
#' * __assay_id:__ _(numeric)_ the ID for assay types (e.g., 1 = OTS28 Early 1),
#' use `get_assay()` to view all available options.
#' * __plate_run_id:__ _(numeric)_ the ID returned from running `add_plate_run()`,
#' the function that creates a new plate run record in the database to associate
#' important metadata with the assay results
#' @returns
#' A table to be passed to `add_raw_assay_results()`:
#' ## 1) raw_assay_results
#' * sample_id
#' * raw_fluorescence
#' * background_value
#' * time
#' * plate_run_id
#' * well_location
#' @examples
#' sample_details = readr::read_csv("data-raw/sample_layout_template_384.csv")
#' process_sherlock(filepath = "data-raw/081022_Chnk_JPE_Early_Plates7-10_results.xlsx",
#'                  sample_details = sample_details,
#'                  plate_size = 384)
#' @export
#' @md
process_sherlock <- function(filepath,
                             sample_type = c("mucus", "fin clip"),
                             layout_type = c("split_plate_early_late", "split_plate_spring_winter", "triplicate",
                                             "single_assay_ots28_early", "single_assay_ots28_late",
                                             "single_assay_ots16_spring", "single_assay_ots16_winter"),
                             plate_run_id = NULL, plate_size = c(96, 384)) {

  if (!class(plate_run_id) == "plate_run") {
    stop(sprintf("the plate_run_id must be created by calling 'add_plate_run'"))
  }

  sample_details <- process_well_sample_details(filepath = filepath,
                                                sample_type = sample_type,
                                                layout_type = layout_type,
                                                plate_run_id = plate_run_id$plate_run_id)

  plate_layout <- process_plate_layout(filepath, plate_size = plate_size)
  has_blk_entries <- nrow(dplyr::filter(plate_layout, psuedo_sample_id == "BLK")) > 0
  wells_used <- sum(!is.na(plate_layout$psuedo_sample_id))
  metadata_keys <- readxl::read_excel(filepath, range = "A1:A100") |> pull()

  read_count_range <- ifelse("Eject plate on completion" %in% metadata_keys, "B18", "B17")
  read_count <- extract_read_count(filepath, at_range = read_count_range)

  cell_ranges <- generate_ranges(plate_size = plate_size, wells_used = wells_used,
                                 time_intervals = read_count)

  layout <- dplyr::left_join(sample_details$data, plate_layout, by="location")

  raw_assay_results <- process_raw_assay_results(filepath, ranges = cell_ranges, plate_size, layout, has_background_fluorescence = has_blk_entries)

  return(
    structure(
      list(data = raw_assay_results),
      class = "sherlock_output",
      filepath = filepath,
      plate_type = layout_type,
      sample_type = sample_type,
      plate_run_id = plate_run_id,
      plate_size = plate_size
    )
  )

}

#' @export
print.sherlock_output <- function(x, ...) {
  cli::cat_rule(sprintf("A Sherlock Output Object"))
  cli::cat_bullet(sprintf("Filepath: '%s'", attr(x, "filepath", exact = TRUE)), bullet_col = "green")
  cli::cat_bullet(sprintf("Layout Type: '%s'", attr(x, "plate_type", exact = TRUE)), bullet_col = "green")
  cli::cat_bullet(sprintf("Sample Type: '%s'", attr(x, "sample_type", exact = TRUE)), bullet_col = "green")
  cli::cat_bullet(sprintf("Plate Run ID: '%s'", attr(x, "plate_run_id", exact = TRUE)), bullet_col = "green")
  cli::cat_bullet(sprintf("Plate Size: '%s'", attr(x, "plate_size", exact = TRUE)), bullet_col = "green")
  cli::cat_bullet(sprintf("Data:"), bullet_col = "green")
  cli::cat_print(x$data)
}


#' Process Raw Assay Results
#' @description A helper function called in `process_sherlock` that reads in
#' an excel containing SHERLOCK output.
process_raw_assay_results <- function(filepath, ranges, plate_size, layout, has_background_fluorescence) {
  # raw fluorescence ----

  if (plate_size == 96) {
    raw_fluorescence <- purrr::map_dfc(ranges$raw_fluorescence,
                                       ~readxl::read_excel(filepath,
                                                           range = .)) |>
      dplyr::mutate(Time = hms::as_hms(Time),
                    dplyr::across(dplyr::everything(), as.character)) |>
      dplyr::select(-tidyselect::contains("...")) |>
      tidyr::pivot_longer(names_to = "location", values_to = "fluorescence", !(tidyselect::starts_with("T"))) |>
      dplyr::left_join(layout) |>
      dplyr::mutate(fluorescence = as.numeric(fluorescence))

    # background values ---
    if (has_background_fluorescence) {

      background_fluorescence <- purrr::map_dfc(ranges$background_fluorescence,
                                                ~readxl::read_excel(filepath,
                                                                    range = .)) |>
        dplyr::mutate(Time = hms::as_hms(Time),
                      dplyr::across(dplyr::everything(), as.character)) |>
        dplyr::select(-tidyselect::contains("...")) |>
        tidyr::pivot_longer(names_to = "location", values_to = "background_fluorescence", !Time)
    }
  } else {
    raw_fluorescence <- purrr::map_dfc(ranges$raw_fluorescence,
                                       ~readxl::read_excel(filepath,
                                                           range = .)) |>
      dplyr::mutate(Time = hms::as_hms(Time...1),
                    dplyr::across(dplyr::everything(), as.character)) |>
      dplyr::select(-tidyselect::contains("...")) |>
      tidyr::pivot_longer(names_to = "location", values_to = "fluorescence", !(tidyselect::starts_with("T"))) |>
      dplyr::left_join(layout) |>
      dplyr::mutate(fluorescence = as.numeric(fluorescence))

    # background values ---
    if (has_background_fluorescence) {

      background_fluorescence <- purrr::map_dfc(ranges$background_fluorescence,
                                                ~readxl::read_excel(filepath,
                                                                    range = .)) |>
        dplyr::mutate(Time = hms::as_hms(Time...1),
                      dplyr::across(dplyr::everything(), as.character)) |>
        dplyr::select(-tidyselect::contains("...")) |>
        tidyr::pivot_longer(names_to = "location", values_to = "background_fluorescence", !Time)
    }
  }

  # raw results encoded as strings because of OVERFLOW and ????? values
  if (has_background_fluorescence) {

    raw_assay_results <- raw_fluorescence |>
      dplyr::left_join(background_fluorescence) |>
      dplyr::select(sample_id, sample_type_id, assay_id, plate_run_id, raw_fluorescence = fluorescence,
                    background_value = background_fluorescence,
                    time = Time, plate_run_id, well_location = location) |>
      dplyr::filter(!is.na(sample_id))

    return(raw_assay_results)
  } else {
    raw_assay_results <- raw_fluorescence |>
      dplyr::mutate(background_fluorescence = NA_real_) |>
      dplyr::select(sample_id, sample_type_id, assay_id, plate_run_id, raw_fluorescence = fluorescence,
                    background_value = background_fluorescence,
                    time = Time, plate_run_id, well_location = location) |>
      dplyr::filter(!is.na(sample_id))

  }
}


#' Process Plate Layout
#' @description helper function for mapping of plate layout location to sample identifier
process_plate_layout <- function(filepath, plate_size) {
  if (plate_size == 96) {
    cell_range <- "C32:N39"
    end_column <- 12
    end_letter <- 8
  } else {
    cell_range <- "C32:Z47"
    end_column <- 24
    end_letter <- 16
  }
  plate_layout <- readxl::read_excel(filepath, range = cell_range,
                                     col_names = as.character(1:end_column)) |>
    dplyr::mutate(letter = letters[1:end_letter]) |>
    tidyr::pivot_longer(names_to = "number", values_to = "psuedo_sample_id", !letter) |>
    dplyr::transmute(location = toupper(paste0(letter, number)), psuedo_sample_id)

  return(plate_layout)
}

#' Get Sample Details
#' @description `process_well_sample_details` reads in the plate run layout so sample identifiers
#' can be mapped to the output of the Synergy H1 reader.
#' @param filepath Synergy H1 reader output excel file with corresponding plate run layout
#' in a sheet titled "Plate Map"
#' @param sample_type either `mucus` or `fin_clip`
#' @param layout_type either `split_plate_early_late`, `split_plate_spring_winter`, `triplicate`,
#' `single_assay_ots28_early`, `single_assay_ots28_late`, `single_assay_ots16_spring`,
#' `single_assay_ots16_winter`
#' @param plate_run_id plate run identifier generated by running `add_plate_run()`
#' @details this function is called when the user wants to interact with the database. There is an alternative
#' version of this function, `process_well_sample_details_offline`, that processes sherlock output without
#' interacting with the database. The output of this function will be used as the `sample_details` argument in
#' `process_sherlock()` i.e. it will be used to connect the generic sample identifiers produced
#' by the Synergy H1 reader to sample identifiers in the database. If the `layout_type` argument is
#' `split_plate`, it divide the plate into columns 1:12 and 13:24 and assigns assays based on the
#' following logic:
#' * `split_plate_early_late`: columns 1:12 are OTS 28 Early and columns 13:24 are OTS 28 Late
#' * `split_plate_spring_winter`: columns 1:12 are OTS 16 Spring and columns 13:24 are OTS 16 Winter
#'
#' If the `layout_type` argument is `triplicate`, the assay ids are assigned as follows:
#' * rows A, E, I, and M are OTS 28 Early
#' * rows B, F, J, and N are OTS 28 Late
#' * rows C, G, K, and O are OTS 16 Spring
#' * rows D, H, L, and P are OTS 16 Winter
#'
#' If the `layout_type` is one of `single_assay_ots28_early`, `single_assay_ots28_late`, `single_assay_ots16_spring`, or
#' `single_assay_ots16_winter`, all samples processed in that plate run will be assigned that assay.
#' @returns a table to be passed to `process_sherlock()`:
#' ## plate_layout
#' * location
#' * sample_id
#' * sample_type_id
#' * assay_id
#' * plate_run_id
#' @export
#' @md
process_well_sample_details <- function(filepath,
                                        sample_type = c("mucus", "fin clip"),
                                        layout_type = c("split_plate_early_late", "split_plate_spring_winter", "triplicate",
                                                        "single_assay_ots28_early", "single_assay_ots28_late",
                                                        "single_assay_ots16_spring", "single_assay_ots16_winter"),
                                        plate_run_id) {

  layout_type <- tolower(layout_type)
  sample_type_id <- ifelse(sample_type == "mucus", 1, 2)

  layout_raw <- suppressMessages(readxl::read_excel(filepath,
                                            sheet = "plate_map"))
  # split plate
  if(layout_type %in% c("split_plate_early_late", "split_plate_spring_winter")) {

    assay_ids <- dplyr::case_when(layout_type == "split_plate_early_late" ~ c(1, 2),
                                  layout_type == "split_plate_spring_winter" ~ c(3, 4))

    plate_layout <- layout_raw |>
      tidyr::pivot_longer(names_to="col_num", values_to = "sample_id", -...1) |>
      dplyr::rename(row_num = ...1) |>
      dplyr::mutate(assay_id = ifelse(col_num %in% 1:12, assay_ids[1], assay_ids[2])) |>
      dplyr::transmute(
        location = paste0(row_num, col_num),
        sample_id,
        sample_type_id = sample_type_id,
        assay_id = assay_id,
        plate_run_id = plate_run_id
      )
  }

  # triplicate
  else if(layout_type == "triplicate") {
    assay_ids <- seq(1:4) # all assays
    plate_layout <- layout_raw |>
      tidyr::pivot_longer(names_to="col_num", values_to = "sample_id", -...1) |>
      dplyr::rename(row_num = ...1) |>
      dplyr::mutate(assay_id = dplyr::case_when(row_num %in% c("A", "E", "I", "M") ~ 1,
                                                row_num %in% c("B", "F", "J", "N") ~ 2,
                                                row_num %in% c("C", "G", "K", "O") ~ 3,
                                                row_num %in% c("D", "H", "L", "P") ~ 4)) |>
      dplyr::transmute(
        location = paste0(row_num, col_num),
        sample_id,
        sample_type_id = sample_type_id,
        assay_id = assay_id,
        plate_run_id = plate_run_id
      )
  }

  # single assay
  else if (layout_type %in% c("single_assay_ots28_early", "single_assay_ots28_late",
                              "single_assay_ots16_spring", "single_assay_ots16_winter")) {
    assay_id <- dplyr::case_when(layout_type == "single_assay_ots28_early" ~ 1,
                                 layout_type == "single_assay_ots28_late" ~ 2,
                                 layout_type == "single_assay_ots16_spring" ~ 3,
                                 layout_type == "single_assay_ots16_winter" ~ 4)

    plate_layout <- layout_raw |>
      tidyr::pivot_longer(names_to="col_num", values_to = "sample_id", -...1) |>
      dplyr::rename(row_num = ...1) |>
      dplyr::transmute(
        location = paste0(row_num, col_num),
        sample_id,
        sample_type_id = sample_type_id,
        assay_id = assay_id,
        plate_run_id = plate_run_id
      )
  }

  plate_layout <- plate_layout|> dplyr::filter(!is.na(sample_id))

  return(
    structure(
      list(data = plate_layout),
      class = "plate_layout",
      plate_type = layout_type,
      filepath = filepath
    )
  )
}

#' @export
print.plate_layout <- function(x, ...) {
  cli::cat_bullet(sprintf("A Plate layout Object"), bullet_col = "green")
  cli::cat_bullet(sprintf("Layout Type: '%s'", attr(x, "plate_type", exact = TRUE)), bullet_col = "green")
  cli::cat_bullet(sprintf("Filepath: '%s'", attr(x, "filepath", exact = TRUE)), bullet_col = "green")
  cli::cat_bullet(sprintf("Data:"), bullet_col = "green")
  cli::cat_print(x$data)

}

expected_layout_colnames <- function() {
  c("location", "sample_id", "sample_type_id", "assay_id", "plate_run_id")
}



#' Extract Previous End Row
#' @description helper function used to identify the previous ending range of cells
#' within the Synergy H1 excel workbook output
#' @param cell_ranges a vector of strings representing the cell ranges of the tables e.g. c("A1:B10", "A11:B21")
#' @examples extract_previous_end_row(c("A1:B10", "A11:B21")) #21
extract_previous_end_row <- function(cell_ranges) {
  as.numeric(
    stringr::str_extract(
      stringr::str_split(cell_ranges[length(cell_ranges)],
                         ":", simplify = TRUE)[2],
      "[0-9]+")
  )
}

#' Generate all cell ranges for tables containing assay results
#' @description helper function used to generate all cell ranges for each type of table
#' within the Synergy H1 excel workbook output
#' @param plate_size either 96 or 384
#' @param wells_used The number of wells containing samples or controls
#' @param time_intervals The number of reads when the samples are being processed
generate_ranges <- function(plate_size, wells_used, time_intervals) {

  if (plate_size == 96) {
    column_header_row <- 43
    result_row_count <- 8 * 4
  } else if (plate_size == 384) {
    column_header_row <- 51
    result_row_count <- 16 * 4
  } else {
    stop(paste("Unknown plate size -", plate_size))
  }

  raw_fl_ranges <- generate_range("raw fluorescence", column_header_row, result_row_count,
                                  wells_used, time_intervals)

  bk_fl_header_row <- extract_previous_end_row(raw_fl_ranges) + 4

  background_fl_ranges <- generate_range("background fluorescence",
                                         bk_fl_header_row, result_row_count,
                                         wells_used, time_intervals)

  results_header_row  <- extract_previous_end_row(background_fl_ranges) + 4


  return(
    list(
      raw_fluorescence = raw_fl_ranges,
      background_fluorescence = background_fl_ranges
    )
  )

}

#' @title Generate a cell range
#' @description helper function used to identify a group of cell ranges that encompass
#' tables containing a type of result from within the Synergy H1 excel workbook output
#' @param table_type the type of results table, either "raw fluorescence", "background fluorescence", or "results"
#' @param column_header_row the row number containing the column headers for the first table of interest
#' @param result_row_count Based on the plate size e.g., 96 well plate has 32 rows or results
#' @param wells_used The number of wells containing samples or controls
#' @param time_intervals The number of reads when the samples are being processed
generate_range <- function(table_type = c("raw fluorescence", "background fluorescence", "results"),
                           column_header_row, result_row_count, wells_used, time_intervals) {

  max_cells <- 96

  if (table_type == "raw fluorescence") {
    start_col_index <- "B"
    end_col_index <- "CU"
    left_offset <- 3
  } else if (table_type == "background fluorescence") {
    start_col_index <- "B"
    end_col_index <- "CT"
    left_offset <- 2
  } else {
    stop(paste("Unknown table type -", table_type))
  }

  if (wells_used <= max_cells) {
    return(sprintf("%s%d:%s%d", start_col_index, column_header_row,
                   grunID::excel_column_index[left_offset + wells_used],
                   column_header_row + time_intervals))
  }

  last_table_cols <- wells_used %% max_cells
  full_tables_count <- floor(wells_used/max_cells)

  letter_col_index <- c(rep(end_col_index, full_tables_count),
                        grunID::excel_column_index[left_offset + last_table_cols])
  cell_ranges <- character(full_tables_count + 1)

  for (i in seq_along(letter_col_index)) {
    end_index <- column_header_row + time_intervals
    cell_ranges[i] <- sprintf("%s%d:%s%d",
                              start_col_index,
                              column_header_row,
                              letter_col_index[i],
                              end_index)
    column_header_row <- end_index + 4
  }

  return(cell_ranges)
}

extract_read_count <- function(filepath, at_range) {
  raw_read_count <- readxl::read_excel(filepath, range = at_range, col_names = FALSE) |>
    dplyr::pull(...1)
  read_count <- as.integer(stringr::str_extract(raw_read_count, "\\d+(?=\\sReads)"))
  return(read_count)
}





