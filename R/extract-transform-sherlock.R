#' Process Sherlock Results
#' @description `process_sherlock()` extracts and transforms result data from the Synergy H1 reader
#' @param filepath path to excel file generated by Synergy H1 software
#' @param sample_details dataframe containing sample information at each well,
#' see the __Sample Details__ section for more information
#' @param plate_size either 96 or 384
#' @details # Sample Details
#' The Synergy H1 result output from plate runs is organized using generic identifiers
#' that need to be mapped to the real sample identifiers in order to properly associate
#'  the results with the correct sample id in the database.The output file’s
#'  “Layout” section contains the well locations for samples encoded as non-unique generic
#'  sample ids (e.g., SPL1, BLK). The number of rows and columns in the Layout vary
#'  based on the plate size. A plate size 96 has rows A:H and columns 1:12 and
#'  a plate size 384 has rows A:P and columns 1:24. The results for each sample are
#'  found within columns that are the letter-number combination of the well location
#'  captured in the Layout section (e.g., if SPL1 is in row A and column 3,
#'  then the measurements at each time step are recorded in a column labeled A3).
#' To map the sample ids to the generic identifiers produced by the Synergy H1 software
#' (e.g., SPL1 and A3), the user must provide the true sample ids and other metadata
#' at each well location in the as a dataframe containing these columns:
#' * __location:__ _(character)_ letter-number combination based on Synergy H1 Layout grid (e.g., A3)
#' * __sample_id:__ _(character)_ unique ID of mucus swab or fin clip made up of site code, year,
#' sample event, sampling bin, and count within sampling bin (e.g., BTC22_3_A_1)
#' * __sample_type:__ _(numeric)_ provide 1 for mucus and 2 for fin clip
#' * __assay_id:__ _(numeric)_ the ID for assay types (e.g., 1 = OTS28 Early 1),
#' use `get_assay()` to view all available options.
#' * __plate_run_id:__ _(numeric)_ the ID returned from running `add_plate_run()`,
#' the function that creates a new plate run record in the database to associate
#' important metadata with the assay results
#' @returns
#' A table:
#' ## 1) raw_assay_results
#' * sample_id
#' * raw_fluorescence
#' * background_value
#' * time
#' * plate_run_id
#' * well_location
#' @examples
#' sample_details = readr::read_csv("data-raw/sample_layout_template_384.csv")
#' process_sherlock(filepath = "data-raw/081022_Chnk_JPE_Early_Plates7-10_results.xlsx",
#'                  sample_details = sample_details,
#'                  plate_size = 384)
#' @export
#' @md
process_sherlock <- function(filepath, sample_details,
                             plate_size = c(96, 384)) {

  plate_layout <- process_plate_layout(filepath, plate_size = plate_size)
  wells_used <- sum(!is.na(plate_layout$psuedo_sample_id))
  read_count <- extract_read_count(filepath)

  cell_ranges <- generate_ranges(plate_size = plate_size, wells_used = wells_used,
                                 time_intervals = read_count)

  layout <- dplyr::left_join(sample_details, plate_layout, by="location")

  raw_assay_results <- process_raw_assay_results(filepath, ranges = cell_ranges, plate_size, layout)

  return(raw_assay_results)

}

#' Process Raw Assay Results
#' @description
process_raw_assay_results <- function(filepath, ranges, plate_size, layout) {
  # raw fluorescence ----

  if (plate_size == 96) {
    raw_fluorescence <- purrr::map_dfc(ranges$raw_fluorescence,
                                       ~readxl::read_excel(filepath,
                                                           range = .)) |>
      dplyr::mutate(Time = hms::as_hms(Time),
                    dplyr::across(dplyr::everything(), as.character)) |>
      dplyr::select(-tidyselect::contains("...")) |>
      tidyr::pivot_longer(names_to = "location", values_to = "fluorescence", !(tidyselect::starts_with("T"))) |>
      dplyr::left_join(layout) |>
      dplyr::mutate(fluorescence = as.numeric(fluorescence))

    # background values ---
    background_fluorescence <- purrr::map_dfc(ranges$background_fluorescence,
                                              ~readxl::read_excel(filepath,
                                                                  range = .)) |>
      dplyr::mutate(Time = hms::as_hms(Time),
                    dplyr::across(dplyr::everything(), as.character)) |>
      dplyr::select(-tidyselect::contains("...")) |>
      tidyr::pivot_longer(names_to = "location", values_to = "background_fluorescence", !Time)
  } else {
    raw_fluorescence <- purrr::map_dfc(ranges$raw_fluorescence,
                                       ~readxl::read_excel(filepath,
                                                           range = .)) |>
      dplyr::mutate(Time = hms::as_hms(Time...1),
                    dplyr::across(dplyr::everything(), as.character)) |>
      dplyr::select(-tidyselect::contains("...")) |>
      tidyr::pivot_longer(names_to = "location", values_to = "fluorescence", !(tidyselect::starts_with("T"))) |>
      dplyr::left_join(layout) |>
      dplyr::mutate(fluorescence = as.numeric(fluorescence))

    # background values ---
    background_fluorescence <- purrr::map_dfc(ranges$background_fluorescence,
                                              ~readxl::read_excel(filepath,
                                                                  range = .)) |>
      dplyr::mutate(Time = hms::as_hms(Time...1),
                    dplyr::across(dplyr::everything(), as.character)) |>
      dplyr::select(-tidyselect::contains("...")) |>
      tidyr::pivot_longer(names_to = "location", values_to = "background_fluorescence", !Time)
  }

  # raw results encoded as strings because of OVERFLOW and ????? values
  raw_assay_results <- raw_fluorescence |>
    dplyr::left_join(background_fluorescence) |>
    dplyr::select(sample_id, sample_type_id, assay_id, plate_run_id, raw_fluorescence = fluorescence,
                  background_value = background_fluorescence,
                  time = Time, plate_run_id, well_location = location) |>
    dplyr::filter(!is.na(sample_id))

  return(raw_assay_results)
}


#' Process Plate Layout
#' @description helper function for mapping of plate layout location to sample identifier
process_plate_layout <- function(filepath, plate_size) {
  if (plate_size == 96) {
    cell_range <- "C32:N39"
    end_column <- 12
    end_letter <- 8
  } else {
    cell_range <- "C32:Z47"
    end_column <- 24
    end_letter <- 16
  }
  plate_layout <- readxl::read_excel(filepath, range = cell_range,
                                     col_names = as.character(1:end_column)) |>
    dplyr::mutate(letter = letters[1:end_letter]) |>
    tidyr::pivot_longer(names_to = "number", values_to = "psuedo_sample_id", !letter) |>
    dplyr::transmute(location = toupper(paste0(letter, number)), psuedo_sample_id)
  return(plate_layout)
}

#' Get Sample Details
#' @description `process_well_sample_details` reads in the plate run layout so sample identifiers
#' can be mapped to the output of the Synergy H1 reader.
#' @param filepath Synergy H1 reader output excel file with corresponding plate run layout
#' in a sheet titled "Plate Map"
#' @param sample_type either `mucus` or `fin_clip`
#' @param layout_type either `split_plate_early_late`, `split_plate_spring_winter`, `triplicate`, or
#' `single_assay`. If `single_assay`, you must specify `single_assay_type`.
#' @param `single_assay_type` assay type if running a plate with only one assay. Either `OTS28 Early`,
#' `OTS28 Late`, `OTS16 Spring`, or `OTS16 Winter`. If not running a single assay for the plate, leave
#' this argument empty.
#' @param plate_run_id plate run identifier generated by running `add_plate_run()`.
#' @details the output of this function will be used as the `sample_details` argument in
#' `process_sherlock()` i.e. it will be used to connect the generic sample identifiers produced
#' by the Synergy H1 reader to sample identifiers in the database. If the `layout_type` argument is
#' `split_plate`, it divide the plate into columns 1:12 and 13:24 and assigns assays based on the
#' following logic:
#' * `split_plate_early_late`: columns 1:12 are OTS 28 Early and columns 13:24 are OTS 28 Late
#' * `split_plate_spring_winter`: columns 1:12 are OTS 16 Spring and columns 13:24 are OTS 16 Winter
#'
#' If the `layout_type` argument is `triplicate`, the assay ids are assigned as follows:
#' * rows A, E, I, and M are OTS 28 Early
#' * rows B, F, J, and N are OTS 28 Late
#' * rows C, G, K, and O are OTS 16 Spring
#' * rows D, H, L, and P are OTS 16 Winter
#'
#' If the `layout_type` is `single_assay`, all sample IDs will be assigned the assay type you
#' pass in as `single_assay_type`.
#' @returns a table to be passed to `process_sherlock()`:
#' ## plate_layout
#' * location
#' * sample_id
#' * sample_type_id
#' * assay_id
#' * plate_run_id
#' @export
#' @md
process_well_sample_details <- function(filepath, sample_type, layout_type, single_assay_type, plate_run_id) {

  layout_type <- tolower(layout_type)
  sample_type_id <- ifelse(sample_type == "mucus", 1, 2)

  layout_raw <- suppressMessages(read_excel(filepath,
                                            sheet = "Plate Map"))
  # split plate
  if(str_detect(layout_type, "split_plate")) {

    assay_ids <- case_when(layout_type == "split_plate_early_late" ~ c(1, 2),
                           layout_type == "split_plate_spring_winter" ~ c(3, 4))

    plate_layout <- layout_raw |>
      pivot_longer(names_to="col_num", values_to = "sample_id", -...1) |>
      rename(row_num = ...1) |>
      mutate(assay_id = ifelse(col_num %in% 1:12, assay_ids[1], assay_ids[2])) |>
      transmute(
        location = paste0(row_num, col_num),
        sample_id,
        sample_type_id = sample_type_id,
        assay_id = assay_id,
        plate_run_id = plate_run_id
      ) |>
      mutate(sample_id = ifelse(sample_id == "NTC", "CONTROL", sample_id))
  }

  # triplicate
  if(layout_type =="triplicate") {
    assay_ids <- seq(1:4) # all assays
    plate_layout <- layout_raw |>
      pivot_longer(names_to="col_num", values_to = "sample_id", -...1) |>
      rename(row_num = ...1) |>
      mutate(assay_id = case_when(row_num %in% c("A", "E", "I", "M") ~ 1,
                                  row_num %in% c("B", "F", "J", "N") ~ 2,
                                  row_num %in% c("C", "G", "K", "O") ~ 3,
                                  row_num %in% c("D", "H", "L", "P") ~ 4)) |>
      transmute(
        location = paste0(row_num, col_num),
        sample_id,
        sample_type_id = sample_type_id,
        assay_id = assay_id,
        plate_run_id = plate_run_id
      ) |>
      mutate(sample_id = ifelse(sample_id == "NTC", "CONTROL", sample_id))
  }

  # single assay
  if(layout_type == "single_assay") {
    if(missing(single_assay_type)){
      stop("you must provide a single assay type if layout_type == single_assay")
    }
    single_assay_type <- tolower(single_assay_type)
    assay_id <- case_when(single_assay_type == "ots28 early" ~ 1,
                           single_assay_type == "ots28 late" ~ 2,
                           single_assay_type == "ots16 spring" ~ 3,
                           single_assay_type == "ots16 winter" ~ 4)

    plate_layout <- layout_raw |>
      pivot_longer(names_to="col_num", values_to = "sample_id", -...1) |>
      rename(row_num = ...1) |>
      transmute(
        location = paste0(row_num, col_num),
        sample_id,
        sample_type_id = sample_type_id,
        assay_id = assay_id,
        plate_run_id = plate_run_id
      ) |>
      mutate(sample_id = ifelse(sample_id == "NTC", "CONTROL", sample_id))
  }

  return(plate_layout|>
           dplyr::filter(!is.na(sample_id)))
}

expected_layout_colnames <- function() {
  c("location", "sample_id", "sample_type_id", "assay_id", "plate_run_id")
}



#' Extract Previous End Row
#' @description helper function used to identify the previous ending range of cells
#' within the Synergy H1 excel workbook output
#' @param cell_ranges a vector of strings representing the cell ranges of the tables e.g. c("A1:B10", "A11:B21")
#' @example extract_previous_end_row(c("A1:B10", "A11:B21")) #21
extract_previous_end_row <- function(cell_ranges) {
  as.numeric(
    stringr::str_extract(
      stringr::str_split(cell_ranges[length(cell_ranges)],
                         ":", simplify = TRUE)[2],
      "[0-9]+")
  )
}

#' Generate all cell ranges for tables containing assay results
#' @description helper function used to generate all cell ranges for each type of table
#' within the Synergy H1 excel workbook output
#' @param plate_size either 96 or 384
#' @param wells_used The number of wells containing samples or controls
#' @param time_intervals The number of reads when the samples are being processed
generate_ranges <- function(plate_size, wells_used, time_intervals) {

  if (plate_size == 96) {
    column_header_row <- 43
    result_row_count <- 8 * 4
  } else if (plate_size == 384) {
    column_header_row <- 51
    result_row_count <- 16 * 4
  } else {
    stop(paste("Unknown plate size -", plate_size))
  }

  raw_fl_ranges <- generate_range("raw fluorescence", column_header_row, result_row_count,
                                  wells_used, time_intervals)

  bk_fl_header_row <- extract_previous_end_row(raw_fl_ranges) + 4

  background_fl_ranges <- generate_range("background fluorescence",
                                         bk_fl_header_row, result_row_count,
                                         wells_used, time_intervals)

  results_header_row  <- extract_previous_end_row(background_fl_ranges) + 4


  return(
    list(
      raw_fluorescence = raw_fl_ranges,
      background_fluorescence = background_fl_ranges
    )
  )

}

#' @title Generate a cell range
#' @description helper function used to identify a group of cell ranges that encompass
#' tables containing a type of result from within the Synergy H1 excel workbook output
#' @param table_type the type of results table, either "raw fluorescence", "background fluorescence", or "results"
#' @param column_header_row the row number containing the column headers for the first table of interest
#' @param result_row_count Based on the plate size e.g., 96 well plate has 32 rows or results
#' @param wells_used The number of wells containing samples or controls
#' @param time_intervals The number of reads when the samples are being processed
generate_range <- function(table_type = c("raw fluorescence", "background fluorescence", "results"),
                           column_header_row, result_row_count, wells_used, time_intervals) {

  max_cells <- 96

  if (table_type == "raw fluorescence") {
    start_col_index <- "B"
    end_col_index <- "CU"
    left_offset <- 3
  } else if (table_type == "background fluorescence") {
    start_col_index <- "B"
    end_col_index <- "CT"
    left_offset <- 2
  } else {
    stop(paste("Unknown table type -", table_type))
  }

  if (wells_used <= max_cells) {
    return(sprintf("%s%d:%s%d", start_col_index, column_header_row,
                   grunID::excel_column_index[left_offset + wells_used],
                   column_header_row + time_intervals))
  }

  last_table_cols <- wells_used %% max_cells
  full_tables_count <- floor(wells_used/max_cells)

  letter_col_index <- c(rep(end_col_index, full_tables_count),
                        grunID::excel_column_index[left_offset + last_table_cols])
  cell_ranges <- character(full_tables_count + 1)

  for (i in seq_along(letter_col_index)) {
    end_index <- column_header_row + time_intervals
    cell_ranges[i] <- sprintf("%s%d:%s%d",
                              start_col_index,
                              column_header_row,
                              letter_col_index[i],
                              end_index)
    column_header_row <- end_index + 4
  }

  return(cell_ranges)
}

extract_read_count <- function(filepath) {
  raw_read_count <- readxl::read_excel(filepath, range = "B18", col_names = FALSE) |>
    dplyr::pull(...1)
  read_count <- as.integer(stringr::str_extract(raw_read_count, "\\d+(?=\\sReads)"))
  return(read_count)
}




