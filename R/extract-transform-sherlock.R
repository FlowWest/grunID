#' Process Sherlock Results
#' @description `process_sherlock()` extracts and transforms result data from the Synergy H1 reader
#' @param filepath path to excel file generated by Synergy H1 software
#' @param sample_details dataframe containing sample information at each well,
#' see the __Sample Details__ section for more information
#' @param plate_size either 96 or 384
#' @details # Sample Details
#' The Synergy H1 result output from plate runs is organized using generic identifiers
#' that need to be mapped to the real sample identifiers in order to properly associate
#'  the results with the correct sample id in the database.The output file’s
#'  “Layout” section contains the well locations for samples encoded as non-unique generic
#'  sample ids (e.g., SPL1, BLK). The number of rows and columns in the Layout vary
#'  based on the plate size. A plate size 96 has rows A:H and columns 1:12 and
#'  a plate size 384 has rows A:P and columns 1:24. The results for each sample are
#'  found within columns that are the letter-number combination of the well location
#'  captured in the Layout section (e.g., if SPL1 is in row A and column 3,
#'  then the measurements at each time step are recorded in a column labeled A3).
#' To map the sample ids to the generic identifiers produced by the Synergy H1 software
#' (e.g., SPL1 and A3), the user must provide the true sample ids and other metadata
#' at each well location in the as a dataframe containing these columns:
#' * __location:__ _(character)_ letter-number combination based on Synergy H1 Layout grid (e.g., A3)
#' * __sample_id:__ _(character)_ unique ID of mucus swab or fin clip made up of site code, year,
#' sample event, sampling bin, and count within sampling bin (e.g., BTC22_3_A_1)
#' * __sample_type:__ _(numeric)_ provide 1 for mucus and 2 for fin clip
#' * __assay_id:__ _(numeric)_ the ID for assay types (e.g., 1 = OTS28 Early 1),
#' use `get_assay()` to view all available options.
#' * __plate_run_id:__ _(numeric)_ the ID returned from running `add_plate_run()`,
#' the function that creates a new plate run record in the database to associate
#' important metadata with the assay results
#' @returns
#' A list containing the following 2 tables:
#' ## 1) raw_assay_results
#' * sample_id
#' * raw_fluorescence
#' * background_value
#' * time
#' * plate_run_id
#' * well_location
#' ## 2) assay_results
#' * sample_id
#' * sample_type_id
#' * assay_id
#' * rfu_back_subtracted
#' * plate_run_id
#' * well_location
#' @examples
#' sample_details = readr::read_csv("data-raw/sample_layout_template_384.csv")
#' process_sherlock(filepath = "data-raw/081022_Chnk_JPE_Early_Plates7-10_results.xlsx",
#'                  sample_details = sample_details,
#'                  plate_size = 384)
#' @export
#' @md
process_sherlock <- function(filepath, sample_details,
                             plate_size = c(96, 384)) {

  plate_layout <- process_plate_layout(filepath, plate_size = plate_size)
  wells_used <- sum(!is.na(plate_layout$psuedo_sample_id))
  read_count <- extract_read_count(filepath)

  cell_ranges <- generate_ranges(plate_size = plate_size, wells_used = wells_used,
                                 time_intervals = read_count)

  layout <- dplyr::left_join(sample_details, plate_layout)

  raw_assay_results <- process_raw_assay_results(filepath, ranges = cell_ranges, plate_size, layout)

  results <- process_assay_results(filepath, range = cell_ranges$results, plate_size, layout)

  return(list(
    raw_assay_results = raw_assay_results,
    assay_results = results
  ))

}

#' Process Raw Assay Results
#' @description
process_raw_assay_results <- function(filepath, ranges, plate_size, layout) {
  # raw fluorescence ----
  raw_fluorescence <- purrr::map_dfc(ranges$raw_fluorescence,
                                     ~readxl::read_excel(filepath,
                                                         range = .)) |>
    dplyr::mutate(Time = hms::as_hms(Time...1),
                  dplyr::across(dplyr::everything(), as.character)) |>
    dplyr::select(-tidyselect::contains("...")) |>
    tidyr::pivot_longer(names_to = "location", values_to = "fluorescence", !Time) |>
    dplyr::left_join(layout)

  # background values ---
  background_fluorescence <- purrr::map_dfc(ranges$background_fluorescence,
                                            ~readxl::read_excel(filepath,
                                                                range = .)) |>
    dplyr::mutate(Time = hms::as_hms(Time...1),
                  dplyr::across(dplyr::everything(), as.character)) |>
    dplyr::select(-tidyselect::contains("...")) |>
    tidyr::pivot_longer(names_to = "location", values_to = "background_fluorescence", !Time)

  # raw results encoded as strings because of OVERFLOW and ????? values
  raw_assay_results <- raw_fluorescence |>
    dplyr::left_join(background_fluorescence) |>
    dplyr::select(sample_id, raw_fluorescence = fluorescence,
                  background_value = background_fluorescence,
                  time = Time, plate_run_id, well_location = location)

  return(raw_assay_results)
}

#' Process Assay Results
#' @description
process_assay_results <- function(filepath, range, plate_size, layout) {

  if (plate_size == 96) {
    stat_id_column <- "...14"
  } else if (plate_size == 384) {
    stat_id_column <- "...26"
  }

  results <- readxl::read_excel(filepath,
                                range = range, col_types = "text") |>
    tidyr::fill(...1) |>
    dplyr::rename(stat_id_column = stat_id_column) |>
    tidyr::pivot_longer(names_to = "number_location", values_to = "RFU", !c(...1, stat_id_column)) |>
    dplyr::arrange(...1, as.numeric(number_location)) |>
    dplyr::transmute(location = paste0(...1, number_location),
                     metric = stat_id_column, RFU = as.numeric(RFU)) |>
    dplyr::filter(!is.na(RFU)) |>
    dplyr::left_join(layout) |>
    dplyr::mutate(metric = stringr::str_remove(metric, "\\s\\[.+\\]")) |>
    dplyr::select(sample_id, sample_type_id, assay_id, rfu_back_subtracted = RFU,
                  plate_run_id, well_location = location)

  return(results)
}

# TODO fix name
#' Process layout
#' @description add plate id
#' @export
process_well_sample_details <- function(filepath, plate_run_id) {
  layout <- read_csv(filepath)
  layout$plate_run_id <- plate_run_uid
  return(layout)
}

#' Process Plate Layout
#' @description helper function for mapping of plate layout location to sample identifier
process_plate_layout <- function(filepath, plate_size) {
  if (plate_size == 96) {
    cell_range <- "C32:N39"
    end_column <- 12
    end_letter <- 8
  } else {
    cell_range <- "C32:Z47"
    end_column <- 24
    end_letter <- 16
  }
  plate_layout <- readxl::read_excel(filepath, range = cell_range,
                                     col_names = as.character(1:end_column)) |>
    dplyr::mutate(letter = letters[1:end_letter]) |>
    tidyr::pivot_longer(names_to = "number", values_to = "psuedo_sample_id", !letter) |>
    dplyr::transmute(location = toupper(paste0(letter, number)), psuedo_sample_id)
  return(plate_layout)
}


expected_layout_colnames <- function() {
  c("location", "sample_id", "sample_type_id", "assay_id", "plate_run_id")
}



#' Extract Previous End Row
#' @description helper function used to identify the previous ending range of cells
#' within the Synergy H1 excel workbook output
#' @param cell_ranges a vector of strings representing the cell ranges of the tables e.g. c("A1:B10", "A11:B21")
#' @example extract_previous_end_row(c("A1:B10", "A11:B21")) #21
extract_previous_end_row <- function(cell_ranges) {
  as.numeric(
    stringr::str_extract(
      stringr::str_split(cell_ranges[length(cell_ranges)],
                         ":", simplify = TRUE)[2],
      "[0-9]+")
  )
}

#' Generate all cell ranges for tables containing assay results
#' @description helper function used to generate all cell ranges for each type of table
#' within the Synergy H1 excel workbook output
#' @param plate_size either 96 or 384
#' @param wells_used The number of wells containing samples or controls
#' @param time_intervals The number of reads when the samples are being processed
generate_ranges <- function(plate_size, wells_used, time_intervals) {

  if (plate_size == 96) {
    column_header_row <- 43
    result_row_count <- 8 * 4
  } else if (plate_size == 384) {
    column_header_row <- 51
    result_row_count <- 16 * 4
  } else {
    stop(paste("Unknown plate size -", plate_size))
  }

  raw_fl_ranges <- generate_range("raw fluorescence", column_header_row, result_row_count,
                                  wells_used, time_intervals)

  bk_fl_header_row <- extract_previous_end_row(raw_fl_ranges) + 4

  background_fl_ranges <- generate_range("background fluorescence",
                                         bk_fl_header_row, result_row_count,
                                         wells_used, time_intervals)

  results_header_row  <- extract_previous_end_row(background_fl_ranges) + 4

  result_ranges <- generate_range("results", results_header_row, result_row_count,
                                  wells_used, time_intervals)

  return(
    list(
      raw_fluorescence = raw_fl_ranges,
      background_fluorescence = background_fl_ranges,
      results = result_ranges
    )
  )

}

#' @title Generate a cell range
#' @description helper function used to identify a group of cell ranges that encompass
#' tables containing a type of result from within the Synergy H1 excel workbook output
#' @param table_type the type of results table, either "raw fluorescence", "background fluorescence", or "results"
#' @param column_header_row the row number containing the column headers for the first table of interest
#' @param result_row_count Based on the plate size e.g., 96 well plate has 32 rows or results
#' @param wells_used The number of wells containing samples or controls
#' @param time_intervals The number of reads when the samples are being processed
generate_range <- function(table_type = c("raw fluorescence", "background fluorescence", "results"),
                           column_header_row, result_row_count, wells_used, time_intervals) {

  max_cells <- 96

  if (table_type == "raw fluorescence") {
    start_col_index <- "B"
    end_col_index <- "CU"
    left_offset <- 3
  } else if (table_type == "background fluorescence") {
    start_col_index <- "B"
    end_col_index <- "CT"
    left_offset <- 2
  } else if (table_type == "results") {
    start_col_index <- "B"
    end_col_index <- "AA"
    left_offset <- 1
  } else {
    stop(paste("Unknown table type -", table_type))
  }

  if (table_type == "results") {
    return(sprintf("%s%d:%s%d", start_col_index, column_header_row,
                   end_col_index,
                   column_header_row + result_row_count))
  }

  if (wells_used <= max_cells) {
    return(sprintf("%s%d:%s%d", start_col_index, column_header_row,
                   grunID::excel_column_index[left_offset + wells_used],
                   column_header_row + time_intervals))
  }

  last_table_cols <- wells_used %% max_cells
  full_tables_count <- floor(wells_used/max_cells)

  letter_col_index <- c(rep(end_col_index, full_tables_count),
                        grunID::excel_column_index[left_offset + last_table_cols])
  cell_ranges <- character(full_tables_count + 1)

  for (i in seq_along(letter_col_index)) {
    end_index <- column_header_row + time_intervals
    cell_ranges[i] <- sprintf("%s%d:%s%d",
                              start_col_index,
                              column_header_row,
                              letter_col_index[i],
                              end_index)
    column_header_row <- end_index + 4
  }

  return(cell_ranges)
}

extract_read_count <- function(filepath) {
  raw_read_count <- readxl::read_excel(filepath, range = "B18", col_names = FALSE) |>
    dplyr::pull(...1)
  read_count <- as.integer(stringr::str_extract(raw_read_count, "\\d+(?=\\sReads)"))
  return(read_count)
}




